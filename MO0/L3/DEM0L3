POO
Abstraccion
Es cuando separamos los datos de un objeto para luego generar un molde, (una clase), cuando creamos la clase gato, realizamos  la abstracción de sus atributos como son el nombre, edad , raza y sexo, como tambien en el método presentar, luego, a partir de esta entidad llamada clase, pudimos crear objetos ya con características definidas en cada uno de estos atributos.


encapsulamiento

Se utiliza cuando es necesario que ciertos métodos o propiedades sean inviolables o inalterables. Se refiere a la ocultación de los detalles internos de una clase para proteger los datos y comportamientos de esa clase de accesos no autorizados o modificaciones accidentales.

HERENCIA
Permite crear nuevas clases a partir de otras. Al tener la clase Gato, pudimos crear el objeto gato1, con los atributos que ya vimos, podemos crear gato2, que va también a tomar propiedades y métodos de la clase Gato. Esto nos da una jerarquía de padre e hijo. 


POLIMORFISMO

Proviene de poli = muchas, morfismo = formas. Se utiliza para crear métodos con el mismo nombre pero con diferente comportamiento.

El polimorfismo es uno de los pilares fundamentales de la programación orientada a objetos (POO) que permite que diferentes clases puedan ser tratadas a través de una interfaz común. En otras palabras, el polimorfismo permite que un mismo método o función se comporte de manera diferente dependiendo del objeto que lo está llamando.

sbrecarga d emetodos
mertodos p[olimorficods
sobvreescritura 

]



llamar a super(), se obtiene una referencia al objeto de la clase padre, lo que permite invocar los métodos de la clase base y aprovechar su implementación existente. La sintaxis para usar super() es simple: super().metodo() llama al método deseado de la clase padre. 


SOLID 

1. Single Responsibility Principle (SRP) - Principio de Responsabilidad Única


Cada clase o función debe tener una única responsabilidad o motivo para cambiar. Esto significa que cada pieza de código debe estar enfocada en hacer una sola cosa bien, lo que facilita su comprensión y mantenimiento.


2. Open/Closed Principle (OCP) - Principio de Abierto/Cerrado 

Las entidades de software (clases, funciones, etc.) deben estar abiertas para la extensión, pero cerradas para la modificación. Esto significa que deberías poder añadir nuevas funcionalidades sin tener que cambiar el código existente.

3. Liskov Substitution Principle (LSP) - Principio de Sustitución de Liskov 

Los objetos de una clase derivada deben poder reemplazar a los objetos de la clase base sin alterar el comportamiento del programa.

4. Interface Segregation Principle (ISP) - Principio de Segregación de Interfaces 

Los clientes no deben verse obligados a depender de interfaces que no utilizan. En lugar de tener una interfaz grande y general, es mejor tener varias interfaces pequeñas y específicas.

5. Dependency Inversion Principle (DIP) - Principio de Inversión de Dependencias 

Los módulos de alto nivel no deben depender de módulos de bajo nivel; ambos deben depender de abstracciones. Esto significa que tu código debería depender de interfaces o clases abstractas, no de implementaciones concretas.

